// RemoveMemberFromChat adds a member to a chat.
func RemoveMemberFromChat(ctx context.Context, db *mongo.Database, chatID primitive.ObjectID, userID primitive.ObjectID) (*Chat, error) {
	var chat Chat
	filter := bson.M{"_id": chatID}
	update := bson.M{"$pull": bson.M{"members": userID}}
	if err := db.Collection(chatCollection).FindOneAndUpdate(ctx, filter, update).Decode(&chat); err != nil {
		return nil, status.Errorf(
			codes.Internal, "removing member from group chat",
		)
	}
	return &chat, nil
}

func (gcs *gopherChatterServer) RemoveMemberFromGroupChat(ctx context.Context, req *gopherchatterv0.RemoveMemberFromGroupChatRequest) (*gopherchatterv0.RemoveMemberFromGroupChatResponse, error) {
	authUserID, err := primitive.ObjectIDFromHex(grpc_ctxtags.Extract(ctx).Values()["auth.sub"].(string))
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, authUserID) {
		return nil, status.Errorf(
			codes.NotFound, "user id in token does not exist",
		)
	}
	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, userID) {
		return nil, status.Errorf(
			codes.NotFound, "user id does not exist",
		)
	}
	chatID, err := primitive.ObjectIDFromHex(req.GetChatId())
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	chat, err := group.GetChat(ctx, gcs.db, chatID)
	if err != nil {
		return nil, err
	}
	if authUserID != chat.Admin {
		return nil, status.Errorf(
			codes.PermissionDenied, "not authorized to remove member",
		)
	}
	if !group.ChatHasMember(chat, userID) {
		return nil, status.Errorf(
			codes.AlreadyExists, "member not in chat",
		)
	}
	updatedChat, err := group.RemoveMemberFromChat(ctx, gcs.db, chatID, userID)
	if err != nil {
		return nil, err
	}
	var cm []string
	for _, e := range updatedChat.Members {
		if e != userID {
			cm = append(cm, e.Hex())
		}

	}
	return &gopherchatterv0.RemoveMemberFromGroupChatResponse{
		ChatId:      updatedChat.ID.Hex(),
		ChatName:    updatedChat.Name,
		ChatAdmin:   updatedChat.Admin.Hex(),
		ChatMembers: cm,
	}, nil
}

// ========================================================================================
// Group
func (gcs *gopherChatterServer) CreateGroupChat(ctx context.Context, req *gopherchatterv0.CreateGroupChatRequest) (*gopherchatterv0.CreateGroupChatResponse, error) {
	authUserID, err := primitive.ObjectIDFromHex(grpc_ctxtags.Extract(ctx).Values()["auth.sub"].(string))
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, authUserID) {
		return nil, status.Errorf(
			codes.NotFound, "user id in token does not exist",
		)
	}
	gc := group.Chat{
		Name:  req.GetChatName(),
		Admin: authUserID,
		Members: []primitive.ObjectID{
			authUserID,
		},
	}
	gcc, err := group.CreateChat(ctx, gcs.db, gc)
	if err != nil {
		return nil, err
	}
	var cm []string
	for _, e := range gcc.Members {
		cm = append(cm, e.Hex())
	}
	return &gopherchatterv0.CreateGroupChatResponse{
		ChatId:      gcc.ID.Hex(),
		ChatName:    gcc.Name,
		ChatAdmin:   gcc.Admin.Hex(),
		ChatMembers: cm,
	}, nil
}

func (gcs *gopherChatterServer) AddContactToGroupChat(ctx context.Context, req *gopherchatterv0.AddContactToGroupChatRequest) (*gopherchatterv0.AddContactToGroupChatResponse, error) {
	authUserID, err := primitive.ObjectIDFromHex(grpc_ctxtags.Extract(ctx).Values()["auth.sub"].(string))
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, authUserID) {
		return nil, status.Errorf(
			codes.NotFound, "user id in token does not exist",
		)
	}
	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, userID) {
		return nil, status.Errorf(
			codes.NotFound, "user id does not exist",
		)
	}
	c := contact.Contact{
		Owner: authUserID,
		User:  userID,
	}
	if !contact.Exists(ctx, gcs.db, c) {
		return nil, status.Errorf(
			codes.AlreadyExists, "user id is not a contact",
		)
	}
	chatID, err := primitive.ObjectIDFromHex(req.GetChatId())
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	chat, err := group.GetChat(ctx, gcs.db, chatID)
	if err != nil {
		return nil, err
	}
	if authUserID != chat.Admin {
		return nil, status.Errorf(
			codes.PermissionDenied, "not authorized to add contact",
		)
	}
	if group.ChatHasMember(chat, userID) {
		return nil, status.Errorf(
			codes.AlreadyExists, "contact already in chat",
		)
	}
	updatedChat, err := group.AddMemberToChat(ctx, gcs.db, chatID, userID)
	if err != nil {
		return nil, err
	}
	var cm []string
	for _, e := range updatedChat.Members {
		cm = append(cm, e.Hex())
	}
	cm = append(cm, userID.Hex())
	return &gopherchatterv0.AddContactToGroupChatResponse{
		ChatId:      updatedChat.ID.Hex(),
		ChatName:    updatedChat.Name,
		ChatAdmin:   updatedChat.Admin.Hex(),
		ChatMembers: cm,
	}, nil
}

// ========================================================================================
// Individual
func (gcs *gopherChatterServer) CreateIndividualChat(ctx context.Context, req *gopherchatterv0.CreateIndividualChatRequest) (*gopherchatterv0.CreateIndividualChatResponse, error) {
	authUserID, err := primitive.ObjectIDFromHex(grpc_ctxtags.Extract(ctx).Values()["auth.sub"].(string))
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, authUserID) {
		return nil, status.Errorf(
			codes.NotFound, "user id in token does not exist",
		)
	}
	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
	if err != nil {
		return nil, status.Errorf(
			codes.Internal, "converting to ObjectID",
		)
	}
	if !user.IDExists(ctx, gcs.db, userID) {
		return nil, status.Errorf(
			codes.NotFound, "user id does not exist",
		)
	}
	c := contact.Contact{
		Owner: authUserID,
		User:  userID,
	}
	if !contact.Exists(ctx, gcs.db, c) {
		return nil, status.Errorf(
			codes.AlreadyExists, "not a contact",
		)
	}
	ic := individual.Chat{
		Members: []primitive.ObjectID{
			authUserID,
			userID,
		},
	}
	if individual.ChatUsersExists(ctx, gcs.db, ic) {
		return nil, status.Errorf(
			codes.AlreadyExists, "individual chat already exists",
		)
	}
	icc, err := individual.CreateChat(ctx, gcs.db, ic)
	if err != nil {
		return nil, err
	}
	var cm []string
	for _, e := range icc.Members {
		cm = append(cm, e.Hex())
	}
	return &gopherchatterv0.CreateIndividualChatResponse{
		ChatId:      icc.ID.Hex(),
		ChatMembers: cm,
	}, nil
}

// func (gcs *gopherChatterServer) RemoveContact(ctx context.Context, req *gopherchatterv0.RemoveContactRequest) (*empty.Empty, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetUserId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match user_id",
// 		)
// 	}
// 	contactID, err := primitive.ObjectIDFromHex(req.GetContactId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": contactID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	if gcs.contacts.FindOneAndDelete(ctx, bson.M{"user_id": userID, "contact_id": contactID}).Err() != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "contact not found",
// 		)
// 	}
// 	return &empty.Empty{}, nil
// }

// func (gcs *gopherChatterServer) SendMessageToGroupChat(ctx context.Context, req *gopherchatterv0.SendMessageToGroupChatRequest) (*gopherchatterv0.SendMessageToGroupChatResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetAuthorId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match author_id",
// 		)
// 	}
// 	authorID, err := primitive.ObjectIDFromHex(req.GetAuthorId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	chatID, err := primitive.ObjectIDFromHex(req.GetChatId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": authorID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	var groupChat bson.M
// 	if err := gcs.groupChats.FindOne(ctx, bson.M{"_id": chatID, "member_ids": authorID}).Decode(&groupChat); err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in group chat",
// 		)
// 	}
// 	createdTimestamp := primitive.NewObjectID().Timestamp()
// 	result, err := gcs.groupChatMessages.InsertOne(ctx, bson.D{
// 		{Key: "chat_id", Value: chatID},
// 		{Key: "author_id", Value: authorID},
// 		{Key: "content", Value: req.GetContent()},
// 		{Key: "created_timestamp", Value: createdTimestamp},
// 	})
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	return &gopherchatterv0.SendMessageToGroupChatResponse{
// 		MessageId: result.InsertedID.(primitive.ObjectID).Hex(),
// 		ChatId:    req.GetChatId(),
// 		AuthorId:  req.GetAuthorId(),
// 		Content:   req.GetContent(),
// 	}, nil

// }

// func (gcs *gopherChatterServer) CreateIndividualChat(ctx context.Context, req *gopherchatterv0.CreateIndividualChatRequest) (*gopherchatterv0.CreateIndividualChatResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	userID, err := primitive.ObjectIDFromHex(claims["sub"].(string))
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	withUserID, err := primitive.ObjectIDFromHex(req.GetWithUserId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": withUserID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	var contact bson.M
// 	if err := gcs.contacts.FindOne(ctx, bson.M{"user_id": userID, "contact_id": withUserID}).Decode(&contact); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "not a contact",
// 		)
// 	}
// 	result, err := gcs.individualChats.InsertOne(ctx, bson.D{
// 		{Key: "member_ids", Value: bson.A{userID, withUserID}},
// 	})
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	return &gopherchatterv0.CreateIndividualChatResponse{
// 		ChatId:    result.InsertedID.(primitive.ObjectID).Hex(),
// 		MemberIds: []string{claims["sub"].(string), req.GetWithUserId()},
// 	}, nil
// }

// func (gcs *gopherChatterServer) SendMessageToIndiviualChat(ctx context.Context, req *gopherchatterv0.SendMessageToIndividualChatRequest) (*gopherchatterv0.SendMessageToIndividualChatResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetAuthorId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match author_id",
// 		)
// 	}
// 	authorID, err := primitive.ObjectIDFromHex(req.GetAuthorId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	chatID, err := primitive.ObjectIDFromHex(req.GetChatId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": authorID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	var individualChat bson.M
// 	if err := gcs.individualChats.FindOne(ctx, bson.M{"_id": chatID, "member_ids": authorID}).Decode(&individualChat); err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in individual chat",
// 		)
// 	}
// 	createdTimestamp := primitive.NewObjectID().Timestamp()
// 	result, err := gcs.individualChatMessages.InsertOne(ctx, bson.D{
// 		{Key: "chat_id", Value: chatID},
// 		{Key: "author_id", Value: authorID},
// 		{Key: "content", Value: req.GetContent()},
// 		{Key: "created_timestamp", Value: createdTimestamp},
// 	})
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	return &gopherchatterv0.SendMessageToIndividualChatResponse{
// 		MessageId: result.InsertedID.(primitive.ObjectID).Hex(),
// 		ChatId:    req.GetChatId(),
// 		AuthorId:  req.GetAuthorId(),
// 		Content:   req.GetContent(),
// 	}, nil
// }

// func (gcs *gopherChatterServer) GetContactsList(ctx context.Context, req *gopherchatterv0.GetContactsListRequest) (*gopherchatterv0.GetContactsListResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetUserId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match user_id",
// 		)
// 	}
// 	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": userID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	opts := options.Find().SetSort(bson.D{{Key: "user_name", Value: 1}})
// 	cursor, err := gcs.contacts.Find(ctx, bson.M{"user_id": userID}, opts)
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in individual chat",
// 		)
// 	}
// 	var result []bson.M
// 	if err = cursor.All(ctx, &result); err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in individual chat",
// 		)
// 	}
// 	var contacts []*gopherchatterv0.Contact
// 	for i := range result {
// 		var user bson.M
// 		if err := gcs.users.FindOne(ctx, bson.M{"_id": result[i]["contact_id"]}).Decode(&user); err != nil {
// 			return nil, status.Errorf(
// 				codes.NotFound, "user not found",
// 			)
// 		}
// 		userID := result[i]["contact_id"].(primitive.ObjectID).Hex()
// 		userName := user["username"].(string)
// 		c := gopherchatterv0.Contact{
// 			UserId:   userID,
// 			UserName: userName,
// 		}
// 		contacts = append(contacts, &c)
// 	}
// 	return &gopherchatterv0.GetContactsListResponse{
// 		UserId:   req.GetUserId(),
// 		Contacts: contacts,
// 	}, nil
// }

// func (gcs *gopherChatterServer) GetIndividualChats(ctx context.Context, req *gopherchatterv0.GetIndividualChatsRequest) (*gopherchatterv0.GetIndividualChatsResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetUserId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match user_id",
// 		)
// 	}
// 	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": userID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	cursor, err := gcs.individualChats.Find(ctx, bson.M{"member_ids": userID})
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in individual chat",
// 		)
// 	}
// 	var result []bson.M
// 	if err = cursor.All(ctx, &result); err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in individual chat",
// 		)
// 	}
// 	var chatIDs []string
// 	for _, e := range result {
// 		chatIDs = append(chatIDs, e["_id"].(primitive.ObjectID).Hex())
// 	}
// 	return &gopherchatterv0.GetIndividualChatsResponse{
// 		UserId:  req.GetUserId(),
// 		ChatIds: chatIDs,
// 	}, nil
// }

// func (gcs *gopherChatterServer) GetGroupChats(ctx context.Context, req *gopherchatterv0.GetGroupChatsRequest) (*gopherchatterv0.GetGroupChatsResponse, error) {
// 	md, ok := metadata.FromIncomingContext(ctx)
// 	if !ok {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")
// 	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
// 		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// 			return nil, status.Errorf(
// 				codes.Internal, "internal error",
// 			)
// 		}
// 		return []byte("gopherchatter"), nil
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	claims, ok := token.Claims.(jwt.MapClaims)
// 	if !ok && !token.Valid {
// 		return nil, status.Errorf(
// 			codes.Unauthenticated, "invalid token",
// 		)
// 	}
// 	if claims["sub"] != req.GetUserId() {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "subject in token must match user_id",
// 		)
// 	}
// 	userID, err := primitive.ObjectIDFromHex(req.GetUserId())
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.Internal, "internal error",
// 		)
// 	}
// 	var user bson.M
// 	if err := gcs.users.FindOne(ctx, bson.M{"_id": userID}).Decode(&user); err != nil {
// 		return nil, status.Errorf(
// 			codes.NotFound, "user not found",
// 		)
// 	}
// 	cursor, err := gcs.groupChats.Find(ctx, bson.M{"member_ids": userID})
// 	if err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in group chat",
// 		)
// 	}
// 	var result []bson.M
// 	if err = cursor.All(ctx, &result); err != nil {
// 		return nil, status.Errorf(
// 			codes.InvalidArgument, "not in group chat",
// 		)
// 	}
// 	var chatIDs []string
// 	for _, e := range result {
// 		chatIDs = append(chatIDs, e["_id"].(primitive.ObjectID).Hex())
// 	}
// 	return &gopherchatterv0.GetGroupChatsResponse{
// 		UserId:  req.GetUserId(),
// 		GroupChats: groupChats,
// 	}, nil
// }